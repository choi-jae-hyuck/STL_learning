

==============================
Thu Jun 13 14:37:27 2019
==============================

//----------------------------------------------------
//2019 STL 5.23 목
//
//알고리즘 함수 알아보기
//
//
//----------------------------------------------------
#include <iostream>
#include <string>
#include <algorithm>
#include <vector>
#include <set>
#include <list>
#include <fstream>
#include <iterator>
#include <iomanip>
#include "String.h"
#include "save.h"
using namespace std;

// 학과자료실에서 단어들.zip을 받기

template<class iter>
typename iter::difference_type my_distance(iter b, iter e);
template<class iter>
typename iter::difference_type my_distance(iter b, iter e, random_access_iterator_tag);
template<class iter>
typename iter::difference_type my_distance(iter b, iter e, input_iterator_tag);
void readData();

struct SP : public pair<string,string> {
	SP(string s) :pair(s, s){
		sort(first.begin(), first.end());
	}
};

vector<SP> readv;

// pair a<b ? => return a.first < b.first || ( !(b.first < a.first) && (a.second < b.second) )
// equal_range !(a<b) && !(b<a)

int main()
{
	readData();
	//메모리를 더 사용하여 문제해결
	
	
	//readv를 first 기준 오름차순으로 정렬한다.
	sort(readv.begin(), readv.end(), [](const SP& a, const SP& b) {
		return a.first < b.first;
	});

	//sp를 "first기준으로 정렬한 단어 쌍.txt"에 저장
//	ofstream out("fist기준으로 정렬한 단어 쌍.txt");


//	for (int i = 0; i < sp.size(); ++i)
//		out << setw(40)<<left<<sp[i].first << "\t" << sp[i].second << endl;

	cout << "-------------------" << endl;
	cout << "  Anagram search" << endl;
	cout << "-------------------" << endl;
	cout << endl;

	//단어를 입력받아 애너그램을 찾아주자
	while (true) {
		cout << "Search :";		string s;		cin >> s;
		SP sp{ s };

		/*		if (binary_search(readv.begin(), readv.end(), sp, [](const SP& a, const SP& b) {
					return a.first < b.first;
				})) {
					cout << "사전에 있는단어" << endl;
					auto p = equal_range(readv.begin(), readv.end(), sp, [](const SP& a, const SP& b) {
						return a.first < b.first;
					});

					int d = distance(p.first, p.second);
					if (d == 1)
						cout << "No Anagram" << endl;
					else {
						//[first, second)
						for (auto i = p.first; i < p.second; ++i)
							cout << i->second << " ";
						cout << endl;
					}
				}
				else
					cout << "사전에 없는 단어" << endl;
			}
			*/

		/*
		auto r = equal_range(readv.begin(), readv.end(), sp, [](const SP& a, const SP& b) {
			return a.first < b.first;
		});

		int d = distance(r.first, r.second);
		if (d == 0) {
			cout << "사전에 없는 단어" << endl;
			continue;
		}
		if (d == 1) {
			cout << "사전에 있지만 애너그램x" << endl;
			continue;
		}
		//진짜 존재하는 단어인지 골라봐야한다.
		bool f = none_of(r.first, r.second, [&s](const SP& a) {
			return a.second == s;
		});
		if (f == false) {
			cout << " 사전에 없는 엉터리단어" << endl;
		}
		cout << "    아나그램" << endl;
		for (auto i = r.first; i < r.second; ++i)
			cout << i->second << "  ";
		cout << endl;
		*/

		
		//모든 애너그램 쌍을 찾아 "애너그램들.txt"에 기록하라.
		ofstream out("애너그램들.txt");
		auto b = readv.begin();
		while (true) {
			b = adjacent_find(b, readv.end(), [](const SP& a, const SP& b) {
				return a.first == b.first;
			});
			if (b == readv.end())
				break;

			auto e = find_if_not(b + 1, readv.end(), [b](const SP& a) {
				return a.first == b->first;
			});
			//[b,e)는 애너그램이다.
			for (auto i = b; i < e; ++i)
				out << i->second << " ";
			out << endl;
			b = e;
		}
		save("소스.cpp");
	}

	
}

template<class iter>
typename iter::difference_type my_distance(iter b, iter e)
{
	return my_distance(b, e, iter::iterator_category());
}
template<class iter>
typename iter::difference_type my_distance(iter b, iter e, random_access_iterator_tag)
{
	return e - b;
}
template<class iter>
typename iter::difference_type my_distance(iter b, iter e, input_iterator_tag)
{
	typename iter::difference_type cnt{ 0 };
	while (b++ != e)
		++cnt;
	return cnt;
}

void readData()
{
	string s;
	ifstream in("단어들.txt");
	while (in >> s)
		readv.push_back(s);
	cout << "모두 " << readv.size() << "개의 단어쌍을 만들었다." << endl;
}